
## C++ 기본

### typedef
- 타입의 이름을 새로이 별칭으로 정의하고 실제 타입이름 대신 별칭으로 사용할 수 있다.

```c++
typedef <타입> <별칭>;
```

### define
- 상수, 매크로를 정의할 수 있다.
```c++
#define <이름> <값>
```

### STL(Standard Template Library)
- STL은 자료구조, 함수 등을 제공하는 라이브러리를 의미한다.
- 알고리즘, 컨테이너, 이터레이터, 펑터를 제공한다.
    - **알고리즘**<br>
    정렬, 탐색 등에 관한 함수로 이루어져 있다. sort()가 대표적이다.
    - **컨테이너**
        - 시퀀스 컨테이너(sequence container)<br>
        데이터를 단순히 저장해 놓는 자료구조를 뜻하며 array, vector, deque, forward_list, list가 있다.
        - 연관 컨테이너(associative container)<br>
        자료가 저장됨에 따라 자동정렬되는 자료구조를 말한다. 중복키가 가능한 것은 이름에 multi가 붙는다. set, map, mutilset, mutilmap이 있다.
        - 정렬되지 않은 연관 컨테이너(unordered associative container)<br>
        자료가 저장됨에 따라 자동정렬이 되지 않는 자료구조를 말한다. unordered_set, unordered_map, unordered_mutiset, unordered_multimap이 있다.
        - 컨테이너 어댑터(container adapter)<br>
        시퀀스 컨테이너를 이용해 만든 자료구조를 뜻하며,stack, queue는 deque로 만들어져 있으며 priority_queue는 vector를 이용해 힙 자료구조롤 만든다.
    - **[이터레이터](#이터레이터)**
    - **펑터**<br>
    함수 호출 연산자를 오버로드하는 클래스의 인스턴스를 말한다.

## 입력과 출력

### 입력
cin은 개행문자(띄어쓰기, 엔터) 직전까지 입력을 받고, scanf는 형식을 지정해서 입력을 받는다.

#### cin

#### scanf
```c++
int scanf ( const char * format, ... );
``` 
- scanf를 활용해 실수타입을 정수타입을 받아보기

#### getline
- cin은 개행문자 직전까지만 받지만, getline을 사용하면 한꺼번에 받을수 있다.
- getline이 호출되기 전 받는입력이 있다면, 버퍼에 개행문자가 남아있어 '\n'이 getline에 바로 입력되어버리는 현상이 발생하므로 버퍼플래시를 해야한다.

### 출력

#### cout
- cout은 기본적으로 실수를 출력하면 일부분만 출력한다.
- 반올림해서 출력하고 싶을 경우, cout.percision(자릿수 + 1);로 자릿수를 정해준다.

#### printf
```c++
int printf ( const char * format, ... );
```   
- 2를 02로, 12는 12로 출력하는 방법 : `printf("%02d\n", b);`
- stirng을 출력할 때는 c_str()함수를 걸어서 출력해야한다.

## 타입과 타입 변환

### 타입
```c++
void, char, string, bool, int, long long, double, unsigned long long
```

#### void 
리턴하는 값이 없다.

*(참고) 함수를 선언할 때는 항상 호출되는 위쪽 부분에 선언을 하는 것을 선호하자.*

#### char, 문자

#### string, 문자열
- char[] 배열로 선언하거나 stirng을 이용해 문자열을 선언할 수 있다.
- 한글로 선언한 문자열의 경우, 문자열[0]을 출력했을 때 잘못되게 출력된다. 왜냐하면 문자열[0] 이렇게 접근한다는 건 0번째 1바이트씩 출력한다는 것을 의미하는데, 한글은 한 글자당 3바이트이기 때문이다.

##### stirng에서 많이 사용하는 메소드 및 함수
- +=<br>
+=의 경우, 해당 문자열을 뒤에 추가해서 확장하는 것이지만, +를 쓰게 되면 새로운 문자열을 만들어 재할당하는 것이다.
- begin()<br>
문자열의 첫번째 요소를 가리키는 이터레이터를 반환한다. 이 이터레이터를 기반으로 *를 통해 해당 위치의 값을 가져올 수 있다.
- end()<br>
문자열의 마지막 요소 그 다음을 가리키는 이터레이터를 반환한다.
- size()<br>
O(1)의 시간복잡도를 가진다.
- insert(위치, 문자열)<br>
O(n)의 시간복잡도를 가진다.
- erase(위치, 크기)<br>
O(n)의 시간복잡도를 가진다.
- pop_back()<br>
O(1)의 시간복잡도를 가진다.
- find(문자열)<br>
    - 특정 문자열을 찾아 위치를 반환한다. 문자열을 못 찾을 경우 `stirng::npos'를 반환하며, O(n)의 시간복잡도를 가진다.
    - `stirng::npos'는 size_t 타입의 최대값을 의마한다. size_t 타입의 최대값은 OS에 따라 달라진다.
- substr(위치, 크기)<br>
O(n)의 시간복잡도를 가진다.
- 아스키코드와 문자열<br>
문자열에서 + 하는 연산은 아스키(ASCII)코드를 기반으로 수행된다.
    - 아스키코드
        - 1963년 미국 ANSI에서 표준화한 정보교환용 7비트 부호체계이며 000(0x00)부터 127(0x7F)까지 총 128개의 부호가 사용된다.
        - 바이트를 구성하는 8비트 중에서 7비트만 쓰도록 제정된 이유는 나머지 1비트를 통신 에러 검출을 위한 용도로 비워두었기 때문이다.
        - 영문 키보드로 입력할 수 있는 모든 기호들이 할당되어 있는 가장 기본적인 부호 체계이다.
        - 97 : a / 65 : A
- reverse() 함수<br>
```c++
void reverse (BidirectionalIterator first, BidirectionalIterator last);
```
- [⭐️split() 함수](01_01_01_split().md)<br>

- 범위기반 for 루프<br>
    ```c++
    for ( range_declaration : range_expression )
        loop_statement
    ```
     - Array의 크기를 입력받은 후 선언할 경우, 범위기반 for 루프를 사용하면 에러가 발생한다.
        - Array는 변수의 크기를 기반으로 런타임시기에 크기가 결정되는 VLA(Variable Length Array)가 되는데 이 VLA를 기반으로 범위기반 for 루프를 실행할 때의 루프의 범위는 컴파일시기에 결정된다.
        - 저 VLA의 크기자체가 컴파일시기에는 0이였다가 런타임에 크기가 결정되기 때문에 에러가 발생한다.
    - Array에서 사용하려면 입력과는 무관하게 전역변수로 컴파일시기에 배열의 크기를 정해놓고 써야하며, 런타임시에 크기가 결정되고 사용하고 싶다면 vector를 사용하면 된다.

- 범위기반 for 루프<br>

- atoi(s.c_str())<br>
문자열, string으로 입력을 받아 입력받은 글자가 문자열인지 숫자인지 확인할 수 있다.

#### bool, 참과 거짓
0이면 false, 0이 아닌 값들은 모두 true가 되며, bool()을 통해 bool형으로 형변환이 가능하다.

#### int, 4바이트짜리 정수
값들의 예상값이 20억을 넘어간다면 int가 아닌 long long을 써야한다.

int의 최대값으로 20억까지가 아닌 987654321 또는 1e9를 사용한다.

```c++
 const int INF = 987654321; 
 const int INF2 = 1e9;
```

`const`를 사용해서 오버플로를 방지한다.

##### int 연산
int로 선언한 변수끼리 연산을 하게 되었을 떄 실수가 나온다면 소수점 아래에 있는 수는 모두 버린다.

##### const 키워드
수정할 수 없는 변수를 정할 때 쓰인다. 보통 INF 같은 것이나 방향벡터를 나타내는 dy, dx에 사용한다.

##### 오버플로(overflow)
타입의 허용범위를 넘어갈 때 발생하는 에러를 뜻한다.

최대범위를 벗어나게 되면 최솟값으로 돌아가게 되는데, 이를 UB(Unexpected Behavior)라고도 한다. 예측할 수 없는 값이 나타나는 것이다.

##### 언더플로(underflow)
오버플로와는 반대로 취급할 수 있는 결과값보다 작아지게 되면 언더플로가 발생된다.

#### long long, 8바이트짜리 정수
int로 표현이 안될 때 사용한다.
```c++
typedef long long ll; 
ll INF = 1e18;
```

#### double, 실수 타입
8바이트이며 소수점 아래로 15자리까지 표현이 가능하다. 

참고로 float는 4바이트, 소수점 아래로 7자리까지 표현이 가능하다.

float와 double 중 double이 더 정확하게 표현이 가능하니 double을 사용하는 것이 좋다.

#### unsigned long long, 8바이트짜리 양의 정수
부호가 없는 정수이다. long long에서 -로 표현할 범위를 몽땅 + 범위에 추가한 타입이다.

### pair와 tuple
pair와 tuple은 타입이나 자료구조는 아니다. c++에서 제공하는 utility 라이브러리 헤더의 템플릿 클래스이다.

pair는 first와 second 라는 멤버 변수를 가지는 클래스이며, 2가지 값을 담아야할 때 사용한다.

tuple은 3가지 이상의 값을 담을 때 쓰는 클래스이다.

pair의 경우, {i, j} || make_pair(i, j)로 만들 수 있다. 이때, i = target.first; j = target.second; 로 꺼내는데, tie(i, j) = target을 통해 i, j로 꺼낼 수 있다.
*(이때 i와 j는 앞서서 변수로 선언되어야 한다.)*

tuple의 경우, {i, j, k ... } || make_tuple(i, j, k ...)로 만들 수 있다. 이때 i = get<0>(target); j = get<1>(target); ... 로 꺼내는데, tie(i, j, k ...) = target을 통해 i, j, k ...로 꺼낼 수 있다.
*(이때 i와 j, k ...는 앞서서 변수로 선언되어야 한다.)*

### auto 타입
auto는 타입추론을 하여 결정되는 타입이다.

auto 타입은 주로 복잡하고 긴 타입의 변수명을 대신할 때 쓰인다.

### 타입변환

#### double을 int형으로 
*(참고) 같은 타입끼리 연산을 하는 것이 중요하다.*

*이때, 산술표현식을 평가할 때 같은 타입을 가져야 하나 이게 맞지 않을 경우 암시적 형변환(Implicit type conversion)이 일어난다. 우선순위는 다음과 같다.*

- *long double (highest*) 
- *double*
- *float*
- *unsigned long long*
- *long long*
- *unsigned long*
- *long*
- *unsigned int*
- *int (lowest)*

*vecotr의 size()는 unsigned int를 반환하므로 연산할 때 형변환을 해줘야 한다.*

#### 타입변환시 주의할 점
```c++
inta=(int)p*100//1 
inta=(int)100*p//2
```
1번 코드만 타입변환이 되므로 주의해야 한다.

#### 문자를 숫자로, 숫자를 문자로
A~Z는 65~90, a~ z 는 97 ~ 122의 아스키 코드를 가지고 있다. 형변환을 통해 사용할 수 있다.

## 메모리와 포인터

### 메모리
컴퓨터의 메모리는 메모리 셀의 연속과 같으며, 각 셀의 크기는 1바이트이고 고유한 주소가 있다.

변수의 메모리 주소란 변수가 사용하는 메모리 주소의 첫번째를 가리킨다.

메모리 주소는 16진수로 표기가 되고 &연산자(ampersand, 앰퍼샌드)를 통해 변수의 메모리 주소를 얻을 수 있다.

OS, 실행시간 등에 따라 주소할당이 달라진다.

변수에 특정 값을 할당하더라도 주소는 변하지 않는다.

### 포인터
자바스크립트는 개발자가 직접 변수에 메모리를 할당하거나 해제할 수 없고 가비지컬렉터를 통해 이를 수행한다.

하위레벨 언어인 C, C++ 등은 가비지컬렉터가 없어 개발자가 직접 필요한 메모리를 예약하고 해제할 수 있으며 포인터 또한 지원한다.

#### 포인터의 개념
변수의 메모리 주소를 담는 타입이 포인터이다.

포인터는 메모리 동적할당, 데이터를 복사하지 않고 함수 매개변수로 사용, 클래스 및 구조체를 연결할 때 사용된다.

`<타입> *` 형태로 포인터를 정의한다. *는 에스터리스크(asterisk operator)라고 불린다.

#### 포인터의 크기
포인터의 크기는 OS가 32bit라면 4바이트, 64bit라면 8바이트로 고정되어있다. 어떤 타입이든 상관없이 무조건 4바이트 아니면 8바이트로 고정된다.

### 역참조 연산자
`*`이라는 기호는 사용하는 위치에 의해 다양한 용도로 사용된다.
1. 이항연산자 : 곱셈 연산
2. 포인터 타입의 선언
3. 역참조(dereference)로 메모리를 기반으로 변수의 값에 접근

### array to pointer decay
배열이 포인터로 부식(decay)되는 현상을 말한다.

이는 배열의 이름을 T * 라는 포인터에 할당하면서 T[N]이란 배열의 크기 정보 N이 없어지고 첫번째 요소의 주소가 바인딩되는 현상을 의미한다.

이를 통해 별의 이름은 배열의 첫번째 주소로써 쓸 수 있다.
*(참고로 vector는 불가능하다.)*

### 프로세스 메모리 구조와 정적할당과 동적할당
운영체제는 프로세스에 적절한 메모리를 할당하는데 다음 구조를 기반으로 할당한다. 
- 스택(stack)<br>
지역변수, 매개변수, 함수가 저장되고 컴파일 시에 크기가 결정된다. 그러나 함수가 함수를 호출하는 등에 따라 런타임 시에도 크기가 변경된다.(동적인 특징)
- 힙(heap)<br>
힙은 동적 할당할 때 사용되며 런타임 시 크기가 결정된다.(동적인 특징)
- 데이터 영역(BSS segment, Data segment)<br>
BSS 영역과 Data 영역으로 나뉘고 정적할당에 관한 부분을 담당한다.(정적인 특징)
- 코드 영역(code segment)<br>
소스코드 들어간다.(정적인 특징)

스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당된다.

#### 정적할당
정적할당은 컴파일단계에서 메모리를 할당하는 것을 말한다.

- Data Segment<br>
전역변수, static, const로 선언되어있는 변수 중 0이 아닌 값으로 초기화된 변수가 이 메모리 영역에 할당된다.
- BSS Segment<br>
전역변수, static, const로 선언되었는 변수 중 0으로 초기화 또는 초기화가 어떠한 값으로도 되어있지 않는 변수들이 이 메모리 영역에 할당된다.
- Code / Text Segment<br>
프로그램의 코드가 들어간다.

#### 동적할당
동적할당은 런타임단계에서 메모리를 할당받는 것을 말한다.

- Stack<br>
지역변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역이다.
<br>
함수가 호출될 때마다 호출될 때의 환경 등 특정 정보가 stack에 계속해서 저장된다.
<br>
재귀함수가 호출된다고 했을 때, 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않는다.
- Heap<br>
동적으로 할당되는 변수들을 담는데, malloc(), free() 함수를 통해 관리할 수 있으며 동적으로 관리되는 자료구조의 경우 Heap영역을 사용한다.

### 이터레이터
컨테이너에 저장되어 있는 요소의 주소를 가리키는 개체를 말하며 포인터를 일반화한 것이다.

주소값을 바로 반환하지 못하며 `&*`을 통해 해당 요소의 주소값을 반환할 수 있다.

#### 이터레이터의 함수

##### begin()

##### end()
보통 it != v.end() 을 사용하는데, 이는 컨테이너를 다 순회하고 컨테이너의 끝에 도착했다는 것을 가리킨다.

##### advance(iterator, cnt)
해당 iterator를 cnt까지 증가시킨다.

### 이터레이터와 포인터의 차이
이터레이터는 어떠한 컨테이너(배열, 맵 등)의 범위 안에서 일부 요소를 가리키며 해당 요소들을 순회할 수 있는 개체이다.
이는 컨테이너의 개체를 참조하는 것이기 때문에 이 자체를 제거할 수 없다.

반면 포인터는 변수의 메모리 주소를 저장하는 개체이며 포인터는 delete를 통해 포인터를 제거할 수 있다.

### 이터레이터 = 일반화된 포인터 인가?
일반화(generalization)는 여러 사례들의 공통된 속성들을 일반적인 개념으로 추상화한 형태를 말한다.

이터레이터는 컨테이너의 구조나 컨테이너 안에 들어가 있는 요소의 타입과는 상관없이 컨테이너에 저장된 데이터를 순회하는 과정을 담당한다.
<br>
즉, 각각의 다른 요소들을 쉽게 탐색할 수 있게 `일반화`한 장치이다.

## 함수

### fill()과 memset()
fill()과 memset()은 배열을 초기화할 때 사용한다.

fill()은 모든 값으로 초기화할 수 있다. 즉, 모든 숫자로 초기화가 가능하다.
반면, memset()같은 경우 -1, 0으로만 초기화가 가능하다.

#### fill()
fill()은 O(n)의 시간복잡도를 가지고, 모든 값을 기반으로 초기화가 가능하며 [first, last)까지 val로 초기화한다.
```c++
void fill (ForwardIterator first, ForwardIterator last, const T& val);
```
*(참고) 1차원의 경우 arr, arr + 10 즉, 배열의 이름 + 숫자로 가능하지만 2차원 이상일 경우에는 반드시 &b[0][0] + 숫자로 해야한다.*

#### fill()로 전체초기 이유
초기화를 시킬 때, 순차적으로 1열에 있는 요소들을 초기화하고 그 다음 2열, 3열 이런식으로 초기화가 일어나기 때문에 생각과는 다른 값이 나온다. 따라서 전체 초기화를 하는게 좋다.

#### memset()
바이트 단위로 초기화를 하며, 0, -1, char형의 하나의 문자(a,b,c...)로 초기화할 때만 사용한다.
```c++
void * memset ( void * ptr, int value, size_t num );
// memset(배열의 이름, k, 배열의 크기)
```

#### 쓰지 말아야 할 초기화 방법 {0, }

```c++
T myarray[N] = {0, };
```
이렇게 초기화하는 것은 초반에 한번하는 정적초기화로써만 유효하고, 동적초기화로써는 동작하지 않다.

따라서 이런 실수를 방지하기 위해 memset()이나 fill()을 쓰는 것이 좋다.

### memcpy()와 copy()
어떤 변수를 깊은 복사할 때, memcpy()와 copy()를 쓴다.

memcpy()는 Array끼리 복사할 때 사용하고, copy()는 Array, vector 모두 사용한다.

#### memcpy()
어떤 변수의 메모리에 있는 값들을 다른 변수의 "특정 메모리값"으로 복사할 때 사용한다.
```c++
void * memcpy ( void * destination, const void * source, size_t num );
```

#### copy()
memcpy()와 똑같은 동작을 하는 함수이다.
```c++
copy (InputIterator first, InputIterator last, OutputIterator result)
```
이때, 복사하는 vector와 복사당하는 vector의 크기를 맞춰주는 것이 중요하다.

### sort()
배열 등 컨테이너들의 요소를 정렬하는 함수이다. 
보통 array나 vector를 정렬할 때 쓰이며 O(nlogn)의 시간복잡도를 가지는 함수이다.
```c++
sort(first, last, *커스텀비교함수)
```
[first, last)라는 범위를 갖으며, sort에는 주소값이 들어가야 하기 때문에 arr[0]이 아닌 배열의 이름인 arr가 들어가게 된다. 즉, last에 배열의 마지막요소가 아닌 그 "다음"의 위치를 넣어주어야 한다.

커스텀비교함수를 넣지 않으면 기본적으로 오름차순이며 이를 커스텀비교함수에 greater<타입>()를 넣어 내림차순으로 변경할 수 있다. 참고로 less<타입>()을 통해 오름차순으로 정렬할 수도 있다.

*(참고) pair를 기반으로 만들어진 vector의 경우, 따로 설정하지 않으면 first, second 순으로 오름차순 정렬된다.
이때, first는 내림차순, second는 오름차순 정렬하고 싶다면 커스텀 비교함수 cmp를 만들어 매개변수로 넣으면 된다.*

### unique()
범위안의 있는 요소 중 앞에서부터 서로를 비교해가며 중복되는 요소를 제거하고 나머지 요소들은 삭제하지 않고 그대로 두는 함수이다. O(n)의 시간복잡도를 가진다.

이때, sort()를 써야 예상하는 로직인 중복된 수를 제거한 값이 나온다. *(참고로, erase(unique())와 함께 쓰는 것이 좋다.)*

### lower_bound()와 upper_bound()
정렬된 배열에서 어떤 값이 나오는 첫번째 지점 또는 초과하는 지점의 위치를 찾아준다.

이때, arr.begin()을 빼어주어야 하는데, lower_bound()와 upper_bound()는 이터레티러르 반환하기 때문이다.

### accumulate()
배열의 합을 쉽고 빠르게 구해주는 함수이다.

### max_element()
배열 중 가장 큰 요소를 추출하는 함수이다. 이 함수는 이터레이터를 반환하기 때문에 `*`를 통해 값을 꺼낼 수 있다.

```c++
template <class ForwardIterator>
ForwardIterator max_element ( ForwardIterator first, ForwardIterator last )
{
if (first==last) return last; ForwardIterator largest = first;
while (++first!=last) if (*largest<*first)
largest=first; return largest;
}
```

### min_element()
배열 중 가장 작은 요소를 추출하는 함수이다. 이 함수는 이터레이터를 반환하기 때문에 `*`를 통해 값을 꺼낼 수 있다.


## 자료구조
자료구조란 데이터들과의 관계, 함수, 명령 등의 집합을 의미하며 데이터에 대해 효율적으로 접근, 수정 등 데이터의 처리를 효율적으로 할 수 있게 만든 구조를 의미한다.

선형자료구조로는 array, stack, queue, linked_list가 있으며, 비선형자료구조로는 graph, tree가 있다.

### vector
vector는 동적으로 요소를 할당할 수 있는 동적 배열이다.

만약 컴파일 시점에 사용해야 할 요소들의 개수를 모른다면 vector를 써야한다.

연속된 메모리 공간에 위치한 같은 타입의 요소들의 모음이며 숫자인덱스를 기반으로 랜덤접근이 가능하며 중복을 허용한다.

탐색과 맨 뒤의 요소를 삭제하거나 삽입하는데 O(1)이 걸리며, 맨 뒤나 맨 앞이 아닌 요소를 삭제하고 삽입하는 데 O(n)의 시간이 걸린다.

```c++
vector<타입> 변수명;
```

#### vector 메소드

##### push_back()
emplace_back()도 동일한 기능을 한다.

##### pop_back()

##### erase()
```c++
iterator erase (const_iterator position);
iterator erase (const_iterator first, const_iterator last);
```

##### find(from, to, value)
O(n)의 시간복잡도를 가진다.

##### clear()

##### fill(from, to, vlaue)

##### 범위기반 for 루프

##### vector의 정적할당

##### 2차원 배열

1. vector<vector<int>> v;
v는 vector안의 vector가 들어가 있는 2차원 배열 타입을 선언한다.
그 이후 v에 temp라는 vector를 push_back해서 2차원 배열을 만든다.
2. vector<vector<int>> v2(10, vector<int>(10, 0));
3. vector<int> v3[10];

##### Array
정적배열이다. 선언할 때 보통 크기를 설정해서 연산을 진행한다.

연속된 메모리 공간에 위치한 같은 타입의 요소들의 모음이며 숫자인덱스를 기반으로 랜덤접근이 가능하며 중복을 혀용한다.

c스타일 = int a[10], std스타일 = array<int, 10> a;

- vector와 달리 메서드가 없고, 배열의 크기를 정해서 선언할 수 있다.
<br> ex) int a[3]
- 크기를 정하지 않고 선언하되 배열을 중괄호로 요소들을 할당 할 수 있다.
<br> ex)int a2[] = {1,2,3,4}

### [⭐️list](01_01_02_list.md)

### [⭐️map](01_01_03_map.md)

### unordered_map
정렬이 되지 않은 map이며 메서드는 map과 동일하다.

- map : 정렬이 됨 / 레드블랙트리 기반 / 탐색, 삽입, 삭제에 O(logN)이 걸림
- unordered_map : 정렬이 안됨 / 해시테이블 기반 / 탐색, 삽입, 삭제에 평균적으로 O(1), 가장 최악의 경우 O(N)

### [⭐️set](01_01_04_set.md)

### multiset
중복되는 요소도 집어넣을 수 있는 자료구조이다. key, value 형태로 집어넣을 필요도 없고 넣으면 자동적으로 정렬된다.

### [⭐️stack](01_01_05_stack.md)

### [⭐️queue](01_01_06_queue.md)

### deque
앞뒤로 삽입, 삭제, 참조가 가능한 자료구조이다.

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){

    deque<int> dq;
    dq.push_front(1);
    dq.push_back(2);
    dq.push_back(3);
    cout << dq.front() << "\n";
    cout << dq.back() << "\n";
    cout << dq.size() << "\n";
    dq.pop_back();
    dq.pop_front();
    cout << dq.size() << "\n";

    return 0;

}
```

### [⭐️struct](01_01_07_struct.md)

### [⭐️priority queue](01_01_08_priority_queue.md)

### 자료구조 시간복잡도 정리

|자료구조|참조|탐색|삽입|삭제|
|------|---|---|---|---|
|배열|O(1)|O(n)|O(n)|O(n)|
|스택|O(n)|O(n)|O(1)|O(1)|
|큐 |O(n)|O(n)|O(1)|O(1)|
|연결리스트|O(n)|O(n)|O(1)|O(1)|
|맵|O(logn)|O(logn)|O(logn)|O(logn)|

스택과 큐같은 경우 가장 앞에 있는 요소를 참조한다고 생각하면 O(1)이지만, 중간에 있는 요소를 참조한다고 했을 때 랜덤접근이 아닌 순차접근만 되기 때문에 O(n)의 시간이 걸린다.

## 값의 의한 호출과 참조에 의한 호출
함수에 값을 전달할 때 값에 의한 호출(call by value)와 참조에 의한 호출(call by reference)가 있다.

### 매개변수

### 값에 의한 호출 
매개변수로 전달되는 변수를 모두 함수 내부에서 복사해서 함수를 실행하는 방법이다.

함수 내부에서 전체 복사가 일어나고 시제 변수와는 다른 주소에 할당되기 때문에 실제 변수와 매개변수로 전달된 변수는 다른 주소값을 가진다.

### 참조에 의한 호출
"변수의 주소"를 매개변수로 함수에 전달하는 방법이다. 

함수 내부에서 해당 매개변수를 변경하게 되면 실제 원본변수에도 반영이 된다.

### 참조에 의한 호출로 넘겨야 할 때
primitive한 타입(double, int ...)은 "값에 의한 호출"로 넘기는게 좋다. 복사가 일어나지만 간단하기 때문에 복사에 대한 코스트가 크지 않다.

reference한 타입(struct, 배열이 차지하는 메모리가 많을 때 ...)은 참조로써 매개변수를 넘기는게 좋다.

## 배열 수정하기 

## 재귀함수와 수학

### [⭐️재귀함수](01_01_09_recursion.md)

## 순열과 조합 

### [⭐️순열](01_01_10_permutation.md)

### [⭐️조합](01_01_11_combination.md)

## 정수론 

### [⭐️최대공약수와 최소공배수](01_01_12_gcd_lcm.md)

### 모듈러 연산
0. a≡bmodn과b≡cmodn은a≡cmodn을의미 
1. [(amodn)+(bmodn)]modn=(a+b)modn 
2. [(amodn)-(bmodn)]modn=(a-b)modn 
3. [(amodn)*(bmodn)]modn=(a*b)modn

### [⭐️에라토스테네스의 체](01_01_13_che.md)

### [⭐️등차수열의 합, 등비수열의 합, 승수, 제곱근 구하기](01_01_14_etc.md)

## 필수로직

### [⭐️1차원 및 2차원 배열 회전](01_01_15_rotate_arr.md)

### ⭐️n진법 변환
```c++
#include<bits/stdc++.h>
using namespace std;

vector<int> v;

int main(){
    int n = 100;
    int b = 2;

    while(n > 1){
        v.push_back(n%b);
        n /= b;
    }
    if(n == 1) v.push_back(1);
    reverse(v.begin(), v.end());
    for(int a : v){
        if(a >= 10) cout << char(a + 55);
        else cout << a;
    }
    return 0;
}
```

## 그외

- 10! = 3628800
- 2^10 = 1024
- 3^10 = 59049