# 그리디

그리디는 **각단계마다 지역적 최적해가 궁극적으로 전역최적해가 되는 것을 말한다.**

**지금의 상태(함수에서는 매개변수)에서 최선이라고 생각하는 해가 결국은 이 문제의 답이 되는 것이다.**

*최고점이다라고 선택했던 것들이 결국에 전역적인 최적해를 갖지 못할 수도 있는 것이 있다.*

> 그래서 항상 어떤 문제를 봤을 때 **그리디부터 생각하는게 아니라 완전탐색, DP, 그리디 순으로 가장 마지막 단계에 그리디를 생각해야 한다.**

그리디는 보통 내가 답이다라고 생각한 명제로부터 시작한다. 즉, **어떠한 경험 + 지식으로 어떠한 명제 또는 논리를 만들고 그걸 기반으로 답을 만들어내는 것이 그리디이다.** 

## 그리디 조건

1. **최적부분구조**를 가지고 있어야 한다.(optiomal substructure)
    지금 이 상태에서 **최선을 다해 선택하는 해가 결국에는 전역적인 최적해로 이어지는 구조**를 의미한다.
    이를 각 단계의 하위문제의 솔루션을 쌓아서 최적의 솔루션을 구할 수 있는 구조라고도 한다.  
2. **탐욕적속성이 증명**이 되어야 한다. 
    보통 **귀류법**으로 증명을 한다. 여기서 귀류법은 간접증명방법중 하나이다. 간접증명은 직접증명하기 어려운 것들에 대해 간접적으로 증명하는 것이다.
    <br>
    ex. $$\sqrt{2} 는 유리수이다. => 거짓이므로, \sqrt{2} 는 무리수이다.$$

> 하지만 이러한 것을... 코테에서 하는 것은 불가능하다.<br>
    무식하게 풀기 >>>>> DP >>>>>> 그리디

> **보통 그리디는 정렬, 우선순위 큐 를 사용하는 2가지의 한정된 방법들이 주로 나온다.**

## 예제문제

1. [1931 회의실 문제](https://www.acmicpc.net/problem/1931)<br>
    ```c++
    #include <bits/stdc++.h>
    using namespace std;

    int n, from, to;;
    int ret = 1;

    int main() {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL); cout.tie(NULL);

        cin >> n;
        vector<pair<int, int>> v;
        for(int i = 0; i < n; i++){
            cin >> from >> to;
            v.push_back({to, from});
        }
        sort(v.begin(), v.end());

        from = v[0].second;
        to = v[0].first;

        for(int i = 1; i < n; i++){
            if(v[i].second < to) continue;
            from = v[i].second;
            to = v[i].first;
            ret++;
        }

        cout << ret;
    }
    ```

2. [1202 보석 도둑](https://www.acmicpc.net/problem/1202)<br>
    ```c++
    #include <bits/stdc++.h>
    using namespace std;

    typedef long long ll;
    ll n, k, ret;

    int main(){
        cin >> n >> k;
        vector<pair<ll, ll>> v(n);
        vector<ll> vv(k);
        for(int i = 0; i < n; i++){
            cin >> v[i].first >> v[i].second ;
        }
        for(int i = 0; i < k; i++){
            cin >> vv[i];
        }
        sort(v.begin(), v.end());
        sort(vv.begin(), vv.end());
        priority_queue<ll> pq;

        int j = 0;
        for(int i = 0; i < k; i++){
            while(j < n && v[j].first <= vv[i]) pq.push(v[j++].second);
            if(pq.size()) {
                ret += pq.top(); 
                pq.pop();
            }
        }

        cout << ret;

        return 0;

    }
    ```
3. [14729 칠무해](https://www.acmicpc.net/problem/14729)<br>
    ```c++
    #include <bits/stdc++.h>
    using namespace std;

    int n;
    double temp;
    priority_queue<double> pq;

    int main(){
        cin >> n;

        for(int i = 0; i < n; i++){
            cin >> temp;
            if(pq.size() == 7){
                pq.push(temp);
                pq.pop();
            }else{
                pq.push(temp);
            }
        }
        vector<double> v;
        while(pq.size()){
            v.push_back(pq.top());
            pq.pop();
        }
        reverse(v.begin(), v.end());

        for(double i : v){
            printf("%.3lf\n", i);
        }

        return 0;
    }
    ```

# 라인스위핑

**하나의 라인을 한번에 빗자루 쓸 듯이 탐색하는 것만으로 점과의 집합, 선과의 집합 등 탐색을 끝내는 것**을 라인스위핑이라고 한다.  

사실 이는 굉장히 고급 알고리즘에 속한다. 교차점, 점과 점의 집합 찾기 등 기하문제를 풀 때 사용되는데 코딩테스트에는 그정도 기하수준은 나오지 않기 때문에 한번에 *무언가 점이나 선들을 쓸어버리면서 문제를 푸는 것이다.* 라고 생각하시면 된다.  

## 예제문제

1. [2170 선 긋기](https://www.acmicpc.net/problem/2170)
<br>
    (+)[1번 문제에 대한 추가 설명](https://yabmoons.tistory.com/618)
<br>
    ```c++
    #include <bits/stdc++.h>
    using namespace std;

    pair<int, int> p[1000004];
    int n, l, r, ret, from, to;

    int main(){
        ios_base::sync_with_stdio(false);
        cin.tie(NULL); cout.tie(NULL);
        
        cin >> n;
        for(int i = 0; i < n; i++){
            cin >> from >> to;
            p[i] = {from, to};
        }
        sort(p, p + n);
        l = p[0].first, r = p[0].second;
        for(int i = 1; i < n; i++){
            if(r < p[i].first){
                ret += r - l;
                r = p[i].second;
                l = p[i].first;
            }else if(p[i].first <= r && p[i].second >= r){
                r = p[i].second;
            }
        }
        ret += r - l;
        
        cout << ret;

        return 0;

    }
    ```

# 투포인터

두개의 포인터를 가지고 탐색하는 알고리즘이다.
1. 시작지점과 끝점 2개로 이루어진 투포인터를 활용해서 문제를 풀기(일반적)
2. 같이 처음시작점에서 같이 시작하여 풀기(1번이 안된다면 사용)

## 예제문제

1. [3273 두 수의 합](https://www.acmicpc.net/problem/3273)<br>
    ```c++
    #include <bits/stdc++.h>
    using namespace std;

    int n, x, ret;


    int main(){
        cin >> n;
        vector<int> a(n);
        for(int i = 0; i < n; i++){
            cin >> a[i];
        }

        cin >> x;

        sort(a.begin(), a.end());

        int l = 0, r = n - 1;

        while(l < r){
            if(a[l] + a[r] == x){
                r--;
                ret++;
            }
            else if( a[l] + a[r] > x) r--;
            else if( a[l] + a[r] < x) l++;
        }

        cout << ret << "\n";

        return 0;

    }
    ```