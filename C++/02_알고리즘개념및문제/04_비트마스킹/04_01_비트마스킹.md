# 비트마스킹

## 이진수를 이용해 불리언배열을 표현할 수 있다.

예를 들어 4는 100, 2는 010, 1은 001 이다.

1. 0번째 비트가 켜져있다 = 0번째 포함되어있다. = 001 = 1이

2. 0, 1번째 비트가 켜져있다. =  0, 1번째 포함되어있다. = 011 = 3 

즉, 이진수를 이용해서 하나의 숫자를 기반, 불리언배열을 표현할 수 있다.

## 비트연산자 기초

### +, -

- & : 비트단위로 AND 연산을 한다.
- | : 비트단위로 OR 연산을 한다.
- ^ : 비트단위로 XOR 연산을 한다.
- ~ : 피연산자의 모든 비트를 반전시킨다.
- << : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
- \>> : 피연산자의 비트 열을 오른쪽으로 이동시킨다.

### &, |

- 0 & 0 : 0
- 0 & 1 : 0
- 1 & 0 : 0
- 1 & 1 : 1

- 0 | 0 : 0
- 0 | 1 : 1
- 1 | 0 : 1
- 1 | 1 : 1

### <<, >>

- a << b 는 a * 2 ^ b
- a >> b 는 (int) a * (1 / 2) ^ b

### ^, ~

- 0 ^ 0 : 0
- 0 ^ 1 : 1
- 1 ^ 0 : 1
- 1 ^ 1 : 0

~value = -(value + 1)

- ~ 0 : 1
- ~ 1 : 0

### idx번째 비트끄기

```
S &= ~(1 << idx)
```

### idx번째 비트 XOR 연산

```
S ^= (1 << idx)
```

### 최하위 켜져있는 비트 찾기

```
idx = (S & -S)
```

### 크기가 n인 집합의 모든 비트를 켜기

```
(1 << n) - 1
```

### idx번째 비트를 켜기

```
S |= (1 << idx)
```

### idx번째 비트가 켜져 있는지 확인하기

```
if(S & (1 << idx))
```

### 경우의수

```c++
#include <bits/stdc++.h>
using namespace std;  
const int n = 4;
int main() {   
	string a[n] = {"사과", "딸기", "포도", "배"};
	for(int i = 0; i < (1 << n); i++){
		string ret = "";
		for(int j = 0; j < n; j++){
			if(i & (1 << j)){
				ret += (a[j] + " ");
			}
		}
		cout << ret << '\n';
	} 
    return 0;
} 
/*

사과 
딸기 
사과 딸기 
포도 
사과 포도 
딸기 포도 
사과 딸기 포도 
배 
사과 배 
딸기 배 
사과 딸기 배 
포도 배 
사과 포도 배 
딸기 포도 배 
사과 딸기 포도 배 
*/
```

### 매개변수

```c++
#include <bits/stdc++.h>
using namespace std;  
const int n = 4;
string a[4] = {"사과", "딸기", "포도", "배"};
void go(int num){
	string ret = "";	
	for(int i = 0; i < 4; i++){
		if(num & (1 << i)) ret += a[i] + " ";
	}
	cout << ret << '\n';
	return;
}
int main() {    
	for(int i = 1; i < n; i++){
		go(1 | (1 << i));
	} 
    return 0;
} 
/*
사과 딸기 
사과 포도 
사과 배
*/
```

